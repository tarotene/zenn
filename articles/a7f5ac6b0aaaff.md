---
title: "Linux システムコール API 探訪"
emoji: "💻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["OS", "Linux", "C"]
published: false
---

## 契機

オペレーティングシステム（**OS**）の教科書として名高い通称 "[OSTEP](https://pages.cs.wisc.edu/~remzi/OSTEP/)" を読み始めたでやっていきます[^motivated]．今回は [プロセス API](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf) の章．

[^motivated]: モチベーションが続いたら続編もやります．というか頑張ってモチベーションを維持します．

## プロセス API とは

プロセス（process）が何であるかをまず明らかにしておく．OS の文脈におけるプロセスとは，一言で言えば CPU の仮想化に伴って生成される**仮想 CPU** の一単位である．本来は物理リソースとして単一の CPU しか無いところに時分割の仕組みを導入して複数個の仮想 CPU を生成できる分，レジスタ値などは別途メモリ空間に払い出す必要がある．一度生成されたプロセスは，こうして他のプロセスとの兼ね合いで状態遷移をしながら専有のメモリ空間などを持つ．

本記事では扱う Process API としては，プロセスの生成と消滅の過程にひとまず限定する．

:::message
ライフサイクルとしては，生成 -> (各種の状態遷移) -> 終了なので初手で生成・終了に着目するのはあながち間違ってはいない．
:::

## プロセスの生成・消滅に関わる API

プロセスとはそもそも OS が提供する仕組みである．したがってユーザ側に委譲されているのは OS に働きかける行為だけである．この働きかけの仕組みとして**システムコール**（あるいはシステムコール API）なるものがしばしば提供される．

Linux もこの例に漏れず，システムコールありきの設計となっている [^hands-on]．Linux で使用可能なシステムコール API は例えば下記の記事を参照:

@[card](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/syscalls.2.html)

[^hands-on]: この記事を手を動かしながら読まれたい場合には [replit](https://replit.com/) などで適当に C の開発環境を用意してください．Linux のシステムコール API の呼び出しには C の開発環境さえあれば十分です．

### `fork()` システムコール

> システムコールの使い方に触れる前に，プロセスの大まかな仕組みについて補足する．
>
> C で適当なプログラムを書いたとする:
>
> ```c:test.c
> int main(void) {
>     return 0;
> }
> ```
>
> これをコンパイルして実行するには通常シェルを起動する必要があるが，このシェルそれ自体がひとつのプロセスになっている．そして，シェルのプロセスを「親プロセス」とすると，実行されるプログラムは「子プロセス」に相当する．つまり，何かプログラムを起動すること自体が `fork()` システムコールの呼び出しに相当し，そこで親子関係が創発する．したがって，「親プロセス」とか「子プロセス」という言葉が登場する際には注意を払う必要がある．なお，当たり前だが上記の `test.c` には `fork()` は一ミリも登場しないので，`fork()` 相当の処理はシェル側がよしなに行ってくれていると考えるべきである．
>
> ```bash
> gcc test.c
> ./a.out
> ```
>
> このことを間接的に確かめるために，システムコール API として `getpid()` ならびに `getppid()` を使ってみる [^getpid]．それぞれ自身のプロセス ID と自身の親のプロセス ID を戻り値に持つ[^one-process-one-id]．
>
> まず，`test.c` を下記のように変更する:
>
> ```c:test.c
> #include <unistd.h>
> #include <stdio.h>
>
> int main(void) {
>     printf("pid: %d\n", getpid());
>     printf("ppid: %d\n", getppid());
>     return 0;
> }
> ```
>
> その上で，もう一度コンパイルを実施し，現在のシェルの PID を `$$` で目視確認 [^bash-process-id] してから実行してみると，ちゃんと C のプログラム `a.out` 側が正しく親プロセスとしてのシェルのプロセス ID を認識していることが分かる:
>
> ```bash
> gcc test.c
> echo $$
> # => 28495 (一例)
> ./a.out
> # => pid: 29672 (一例)
> # => ppid: 28495 (一例)
> ```
>
> つまり，プロセスツリーの構造は（上記の実行例では）少なくともプロセス ID `28495` を親とし プロセス ID `29672` を子とする親子エッジを含んでいると言える．
>
> なお，直後に `ps` でプロセス `ID` をなめてみても C のプログラム `a.out` に対応するプロセス ID は存在していないことも分かる．つまり，実行が終わった時点でそのプロセスは「終了」扱いなので，何とも正しい結果である[^os-design]．

[^getpid]: `getpid()` ならびに `getppid()` の使い方は例えば<https://linuxjm.osdn.jp/html/LDP_man-pages/man2/getpid.2.html>を参照．
[^one-process-one-id]: これからやろうとしていることは `1` ID `1` プロセスであるという当たり前の仮定の検証でもある．
[^bash-process-id]: 根拠: <https://www.gnu.org/software/bash/manual/bash.html#index-_0024>
[^os-design]: こういういかにもデータ構造の操作を伴ってそうな処理を見ると，プログラムの起動・終了がとてもアトミックとは言えない一連の処理によって行われていることが垣間見える．仮に起動時・終了時に不正な割り込みを掛けたりするとポインタの解放忘れによるメモリリークが起こりうることも想像に難くない．OS の設計・実装者には脱帽である．

`fork()` システムコールは，特に C のプログラム中で呼び出される場合には，自身を親として子プロセスを文字通りフォークするのに用いられる．

初見の人が驚きそうな `fork()` の仕様の一つに，実際にフォークされたプロセスの行き場所は `fork()` が `return` した瞬間である[^if-returns]，というものがある．

[^if-returns]: 実際に `return` したその瞬間かと言えば，ちょっと語弊がありそうだけど記事中での無矛盾性とわかり易さのためにこう書いた．あるいは「行き場所」という言葉の定義がこれであると解釈してほしい．

この意味を理解するには，下記のようなコードを書いて実際に実行してみるのが早い:

```c:fork-test.c
#include <stdio.h>
#include <unistd.h>

int main(void) {
  printf("pid (initial): %d\n", getpid());

  int rc = fork();
  if (rc < 0) {
    printf("fork failed\n");
    return -1;
  }

  if (rc == 0) {
    printf("pid (child): %d\n", getpid());
    return 0;
  }

  printf("pid (parent): %d\n", getpid());
  return 0;
}
```

このコードが実施していることを要素分解すると次のようになる:

1. 大元のプロセス ID の確認:

    ```c
    printf("pid (initial): %d\n", getpid());
    ```

2. 子プロセスを新たに `1` つフォーク・エラー処理:

    ```c
    int rc = fork();
    if (rc < 0) {
        printf("fork failed\n");
        return -1;
    }
    ```

    フォークに失敗すると `fork()` の戻り値として負数が設定されるのは仕様．